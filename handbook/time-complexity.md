## 시간 복잡도

### 시간 복잡도란?
알고리즘의 성능을 나타내는 지표로, **입력 크기에 대한 연산 횟수**의 상한을 의미한다.

---

### **알고리즘 수행 시간을 측정하는 방법**

#### 1. **최악의 경우 고려하기**
시간 복잡도를 분석할 때는 주로 **최악의 경우**를 고려한다. 이는 알고리즘이 입력 데이터에 따라 성능이 달라질 수 있기 때문이다. 최악의 경우를 기준으로 하면, 알고리즘의 성능이 보장될 수 있다.


- 배열에서 특정 값을 찾는 경우, 값이 **존재하지 않을 때**가 최악의 경우이다.
- 정렬 알고리즘에서는 데이터가 **역순으로 정렬되어 있을 때** 최악의 경우가 될 수 있다.

#### 2. **점근적 표기법 활용하기**
점근적 표기법은 입력 크기 n이 매우 클 때(즉, **무한대에 가까울 때**) 알고리즘의 수행 시간을 나타내는 방법이다. 이는 상수 시간이나 작은 데이터에 의한 영향을 무시하고 **가장 중요한 증가율**을 나타낸다.

---

### **빅오 표기법(Big-O Notation)**

#### 빅오 표기법이란?
빅오 표기법은 **최악의 경우 시간 복잡도**를 표현하는 표기법이다. 알고리즘의 수행 시간이 입력 크기에 따라 얼마나 빨리 증가하는지를 나타낸다. 주로 아래와 같은 형태로 작성된다.


`O(f(n))`


여기서 f(n)은 입력 크기 n에 따른 알고리즘의 시간 증가율을 나타낸다.

---

### **대표적인 빅오 시간 복잡도**

| 시간 복잡도        | 설명                                             | 예시 알고리즘               |
|-------------------|------------------------------------------------|--------------------------|
| O(1)         | **상수 시간**: 입력 크기와 상관없이 일정한 시간    | 배열의 특정 인덱스 접근    |
| O(log n)    | **로그 시간**: 입력 크기가 커질수록 느리게 증가     | 이진 탐색                |
| O(n)         | **선형 시간**: 입력 크기에 비례                    | 선형 탐색                |
| O(nlog n)  | **선형 로그 시간**: 입력 크기와 로그의 곱           | 병합 정렬, 퀵 정렬        |
| O(n^2)       | **제곱 시간**: 입력 크기의 제곱에 비례             | 버블 정렬, 선택 정렬      |
| O(2^n)       | **지수 시간**: 입력 크기가 증가할 때 매우 빠르게 증가 | 피보나치(재귀적 구현)     |

---
### **시간 복잡도를 코딩테스트에 활용하는 방법**

**1. 빅오 표기법을 활용해 제한 시간 점검하기**

코딩 테스트에서는 보통 **제한 시간 1초**가 주어진다.  
1초 동안 컴퓨터가 수행할 수 있는 연산의 최대 횟수는 **약 10^8 번**이다.  
알고리즘의 빅오 표기법을 통해 입력 크기에 따라 예상 연산 횟수를 계산하고, 제한 시간 안에 결과를 낼 수 있는지 점검해야 한다.


**2. 시간 복잡도에 따른 최대 연산 횟수**

입력 크기 n이 주어졌을 때, 다양한 시간 복잡도에서 수행 가능한 연산 횟수는 아래와 같다:

| **시간 복잡도**      | **입력 크기 n** | **1초 동안 가능한 최대 n**     |
|-----------------------|---------------------|-----------------------------------|
| O(1)              | 상수 시간          | 제한 없음 (즉시 처리)              |
| O(\log n)         | 로그 시간          | 약 10^{18} (거의 모든 상황 가능) |
| O(n)              | 선형 시간          | 10^8                         |
| O(n \log n)       | 선형 로그 시간     | 10^6~10^7                |
| O(n^2)            | 제곱 시간          | 10^3~10^4                |
| O(n^3)            | 세제곱 시간        | 10^2~10^3                |
| O(2^n)            | 지수 시간          | 20                           |

예:
- 입력 크기 n = 10^6: O(n), O(n log n) 정도의 알고리즘이 적합하다.
- 입력 크기 n = 100: O(n^3) 또는 O(2^n)도 가능하다.

---

### **시간 복잡도 계산해보기**


#### **1. 별 찍기 문제**

**문제 설명**

입력으로 n이 주어지면 n개의 줄에 별(`*`)을 출력한다.  
예: n = 3
```
*
**
***
```

#### **JavaScript 코드**
```javascript
function printStars(n) {
  for (let i = 1; i <= n; i++) {
    console.log("*".repeat(i));
  }
}

printStars(3);
```

#### **시간 복잡도 계산**
1. **루프 구조 분석**:
   - `for` 루프는 n번 실행된다.
   - 각 반복에서 `*`를 출력하는 연산은 i번 수행된다 (1, 2, 3, ..., n).

2. **총 연산 횟수**:
   - 1 + 2 + 3 + ... + n = n(n+1)/2
   - 이는 O(n^2)로 표현할 수 있다.

#### **결론**:
- 입력 크기 n이 크면 연산 횟수가 급격히 증가하므로 n \leq 10^3 정도에서 사용하기 적합하다.

---

### **2. 박테리아 수명 문제**

#### **문제 설명**:
박테리아가 1초마다 두 배로 증식한다. 초기 개수와 시간이 주어졌을 때, t초 후 박테리아의 개수를 구한다.

입력:
- 초기 개수: a (1 ≤ a ≤ 10^6)
- 시간: t (1 ≤ t ≤ 20)

출력:
- t초 후 박테리아의 개수.

#### **JavaScript 코드**:
```javascript
function bacteriaGrowth(a, t) {
  return a * (2 ** t);
}

console.log(bacteriaGrowth(1, 10)); // 출력: 1024
console.log(bacteriaGrowth(2, 20)); // 출력: 2097152
```

#### **시간 복잡도 계산**:
1. **연산 구조 분석**:
   - `2 ** t`는 t번의 곱셈 연산으로 계산된다.
   - t는 최대 20이므로, 이 연산은 상수 시간으로 간주할 수 있다.

2. **시간 복잡도**:
   - 이 코드는 입력 크기 t에 관계없이 단일 계산으로 결과를 반환하므로, O(1)이다.

#### **결론**:
- 매우 빠르게 수행되며, t가 20과 같이 작더라도 효율적으로 동작한다.