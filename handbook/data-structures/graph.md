## **그래프**

### **1. 그래프의 개념**
- **용어 정리**
  - **노드(Node):** 그래프에서 데이터를 담고 있는 기본 단위. 정점(Vertex)이라고도 불림
  - **간선(Edge):** 노드와 노드를 연결하는 선으로, 관계나 경로를 나타냄
  - **가중치(Weight):** 간선에 부여된 값으로, 거리, 비용, 시간 등을 나타낼 수 있음

- **그래프의 특징과 종류**
  - **방향성**
    - 방향 그래프: 간선에 방향이 있음 (예: A → B)
    - 무방향 그래프: 간선에 방향이 없음 (예: A ↔ B)
  - **가중치**
    - 가중치 그래프: 간선에 가중치가 있는 그래프
    - 비가중치 그래프: 간선에 가중치가 없는 그래프
  - **순환**
    - 순환 그래프: 한 노드에서 출발해 다시 그 노드로 돌아올 수 있는 경로가 존재
    - 비순환 그래프: 그런 경로가 존재하지 않음

- **그래프 구현**
  - **인접 행렬 (Adjacency Matrix)**
    - 설명: 2차원 배열을 사용하여 그래프를 표현. 노드 간의 연결 여부를 행렬로 나타냄
    - 장점: 특정 두 노드의 연결 여부를 O(1)의 시간 복잡도로 확인할 수 있음
    - 단점: 메모리 사용량이 많으며, 희소 그래프처럼 간선 수가 적은 경우 비효율적임
  
  - **인접 리스트 (Adjacency List)**
    - 설명: 배열이나 리스트를 사용하여 각 노드와 연결된 노드들을 저장
    - 장점: 메모리 효율적이며, 간선 수가 적은 희소 그래프에 적합
    - 단점: 특정 노드 간의 연결 여부를 확인하는 데 O(E)의 시간이 소요될 수 있음 (E는 간선의 개수)

- **참고**) 실제 문제 풀이에서는 시간 제약으로 인해 인접 행렬 방식이 자주 사용되며, 노드 개수가 1000개 미만인 경우 인접 행렬을 사용하는 것이 일반적.

---

### **2. 그래프 탐색**

1. **깊이 우선 탐색 (DFS: Depth-First Search)**
   - **방법**
     - 스택을 활용하거나, 재귀 호출을 사용하여 구현
     - 한 노드를 탐색한 후, 연결된 다른 노드를 끝까지 탐색한 뒤 돌아옴
   - **특징**
     - 백트래킹과 함께 사용되며, 탐색할 노드가 깊은 구조를 가질 때 유용함
     - 코딩 테스트에서는 탐색 문제가 나왔을 때, 또는 최단 경로를 구하는 문제가 아닐 때 주로 사용

2. **너비 우선 탐색 (BFS: Breadth-First Search)**
   - **방법**
     - 큐를 활용하여 구현
     - 시작 노드에서 가까운 노드부터 순차적으로 탐색
   - **특징**
     - 최단 경로를 찾는 문제에 자주 사용됨
     - BFS를 통해 최단 거리를 구할 때는 일반적으로 비가중치 그래프에서 활용됨

---

### **3. 그래프 최단 경로 구하기**

1. **다익스트라 알고리즘 (Dijkstra’s Algorithm)**
   - **목적**
     - 가중치가 있는 그래프에서 특정 시작점에서 다른 모든 노드까지의 최단 경로를 구함
   - **장단점 및 특징**
     - 장점: 음의 가중치가 없는 그래프에서 빠르게 동작
     - 단점: 음의 가중치가 존재하면 올바른 결과를 보장하지 못함
     - 특징: 우선순위 큐를 활용하면 시간 복잡도를 줄일 수 있음
   - **시간 복잡도**
     - 일반적인 구현: O(V^2) (V는 노드의 개수)
     - 우선순위 큐(Heap)를 사용한 구현: O((V + E) \* log V) (E는 간선의 개수)

2. **벨만-포드 알고리즘 (Bellman-Ford Algorithm)**
   - **목적**
     - 가중치가 있는 그래프에서 최단 경로를 구하며, 음의 가중치를 처리할 수 있음
   - **장단점 및 특징:**
     - 장점: 음의 가중치가 있는 그래프에서도 최단 경로를 구할 수 있음
     - 단점: 시간 복잡도가 높아, 다익스트라 알고리즘보다 느림
     - 특징: 모든 간선을 반복적으로 확인하며 최단 경로를 업데이트함
   - **시간 복잡도**
     - O(V \* E) (V는 노드의 개수, E는 간선의 개수)
