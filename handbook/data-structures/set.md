## 집합 (Set)

### 1. **집합과 상호배타적 집합의 개념**
- **집합의 정의**  
  - 순서와 중복이 없는 원소들의 모임
  - 주요 특징 : 유한집합, 무한집합, 공집합, 상호배타적 집합 등으로 구분됨

- **상호배타적 집합 (Disjoint Set)**  
  - 서로 교집합이 없는 집합
  - 활용 분야

    코딩테스트에서는 그래프 알고리즘에서 사이클 확인하기 위해 주로 사용된다.

    2. **이미지 분할** : 이미지의 서로 다른 영역 구분
    3. **도로 네트워크 구성** : 도로가 교차하지 않도록 설계
    4. **최소 신장 트리(MST)** : 간선 추가 시 사이클 여부 판단
    5. **게임 개발** : 캐릭터의 동작 분리 및 제어
    6. **클러스터링** : 서로 겹치지 않도록 그룹화

---

### 2. **집합의 표현 방법**
- **트리를 활용한 표현**
  - **대표 원소 (Root)** : 집합을 대표하는 원소로, 트리 형태에서는 루트 노드로 표현
  - **배열로 트리 표현**
    - 배열의 **인덱스** : 해당 노드
    - 배열의 **값** : 부모 노드

---

### 3. **유니온-파인드 알고리즘**
집합 연산 중 **합치기**(Union)와 **탐색**(Find)을 효율적으로 수행하기 위한 알고리즘

#### (1) **파인드 연산 (Find)**
- 특정 노드의 **루트 노드**를 찾는 연산
- 활용 : 두 노드가 같은 집합에 속해 있는지 확인
- **탐색 과정**
  1. 현재 노드의 부모 노드를 확인
  2. 부모 노드가 루트 노드가 아니면, 부모 노드를 재귀적으로 탐색
  3. 루트 노드에 도달하면 연산 종료
- **시간 복잡도 문제**
  - 트리 높이가 클수록 시간 복잡도 증가 (최악 : `O(N)`)

- **경로 압축 (Path Compression)**
  - 트리 높이를 줄여 탐색 속도 개선
  - 모든 노드가 루트 노드를 직접 가리키도록 업데이트

#### (2) **유니온 연산 (Union)**
- 두 집합을 합치는 연산
- **연산 과정**
  1. 두 집합의 루트 노드를 찾는다
  2. 루트 노드의 값을 비교한다
  3. 두 루트 노드를 동일하게 만들어 집합을 합친다
     - 어느 루트 노드를 선택해도 상관 없음

- **시간 복잡도 문제**
  - 트리 깊이가 깊어지면 연산 비용 증가

- **랭크 기반 유니온 (Union by Rank)**
  - 트리의 깊이를 줄이는 방식
  - **랭크(Rank)**: 루트 노드 기준으로 가장 깊은 노드까지의 경로 길이
  - **연산 과정**
    1. 두 집합의 루트 노드와 랭크를 확인
    2. 랭크 값을 비교
       - **랭크가 다를 경우** : 랭크가 큰 루트 노드를 기준으로 합침
       - **랭크가 같을 경우** : 아무 루트 노드나 선택해 합치고, 새로운 루트 노드의 랭크를 1 증가

---

### 4. **유니온-파인드 알고리즘의 장점**
- 트리 기반의 자료구조로 **효율적인 집합 연산** 수행
- 경로 압축과 랭크 기반 유니온으로 시간 복잡도를 `O(a(N))`로 줄임
  - `O(a(N))` : 거의 상수에 가까운 매우 낮은 시간 복잡도.