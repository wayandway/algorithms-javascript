## 집합 (Set)

### 1. **집합과 상호배타적 집합의 개념**
- **집합의 정의**  
  - 순서와 중복이 없는 원소들의 모임
  - 주요 특징 : 유한집합, 무한집합, 공집합, 상호배타적 집합 등으로 구분됨

- **상호배타적 집합 (Disjoint Set)**  
  - 서로 교집합이 없는 집합
  - 활용 분야

    코딩테스트에서는 그래프 알고리즘에서 사이클 확인하기 위해 주로 사용된다.

    2. **이미지 분할** : 이미지의 서로 다른 영역 구분
    3. **도로 네트워크 구성** : 도로가 교차하지 않도록 설계
    4. **최소 신장 트리(MST)** : 간선 추가 시 사이클 여부 판단
    5. **게임 개발** : 캐릭터의 동작 분리 및 제어
    6. **클러스터링** : 서로 겹치지 않도록 그룹화

---

### 2. **집합의 표현 방법**
- **트리를 활용한 표현**
  - **대표 원소 (Root)** : 집합을 대표하는 원소로, 트리 형태에서는 루트 노드로 표현
  - **배열로 트리 표현**
    - 배열의 **인덱스** : 해당 노드
    - 배열의 **값** : 부모 노드

---

### 3. **유니온-파인드 알고리즘**
집합 연산 중 **합치기**(Union)와 **탐색**(Find)을 효율적으로 수행하기 위한 알고리즘

#### (1) **파인드 연산 (Find)**
- 특정 노드의 **루트 노드**를 찾는 연산
- 활용 : 두 노드가 같은 집합에 속해 있는지 확인
- **탐색 과정**
  1. 현재 노드의 부모 노드를 확인
  2. 부모 노드가 루트 노드가 아니면, 부모 노드를 재귀적으로 탐색
  3. 루트 노드에 도달하면 연산 종료
- **시간 복잡도 문제**
  - 트리 높이가 클수록 시간 복잡도 증가 (최악 : `O(N)`)

- **경로 압축 (Path Compression)**
  - 트리 높이를 줄여 탐색 속도 개선
  - 모든 노드가 루트 노드를 직접 가리키도록 업데이트

#### (2) **유니온 연산 (Union)**
- 두 집합을 합치는 연산
- **연산 과정**
  1. 두 집합의 루트 노드를 찾는다
  2. 루트 노드의 값을 비교한다
  3. 두 루트 노드를 동일하게 만들어 집합을 합친다
     - 어느 루트 노드를 선택해도 상관 없음

- **시간 복잡도 문제**
  - 트리 깊이가 깊어지면 연산 비용 증가

- **랭크 기반 유니온 (Union by Rank)**
  - 트리의 깊이를 줄이는 방식
  - **랭크(Rank)**: 루트 노드 기준으로 가장 깊은 노드까지의 경로 길이
  - **연산 과정**
    1. 두 집합의 루트 노드와 랭크를 확인
    2. 랭크 값을 비교
       - **랭크가 다를 경우** : 랭크가 큰 루트 노드를 기준으로 합침
       - **랭크가 같을 경우** : 아무 루트 노드나 선택해 합치고, 새로운 루트 노드의 랭크를 1 증가

---

### 4. **유니온-파인드 알고리즘의 장점**
- 트리 기반의 자료구조로 **효율적인 집합 연산** 수행
- 경로 압축과 랭크 기반 유니온으로 시간 복잡도를 `O(a(N))`로 줄임
  - `O(a(N))` : 거의 상수에 가까운 매우 낮은 시간 복잡도.

---
- 유니온-파인드 알고리즘 간단하게 구현하기
```js
// 루트 노드 찾는 함수
function find(parents, x) {
  // 만약 x의 부모가 자기 자신이면, 즉 x가 루트 노드라면
  if (parents[x] === x) {
    return x;
  }

  // 그렇지 않다면 x의 부모를 찾아서 parents[x]에 저장하고,
  // 그 부모 노드의 루트 노드를 찾아서 parents[x]에 저장한다.
  parents[x] = find(parents, parents[x]);
  return parents[x]; // parents[x]를 반환한다.
}

// 두 개의 집합을 합치는 함수
function union(parents, x, y) {
  const root1 = find(parents, x); // x가 속한 집합의 루트 노드 찾기
  const root2 = find(parents, y); // y가 속한 집합의 루트 노드 찾기

  parents[root2] = root1; // y가 속한 집합을 x가 속한 집합에 합침
}

function solution(k, operations) {
  const parents = Array.from({ length: k }, (_, i) => i); // 처음에는 각 노드가 자기 자신을 부모로 가지도록 초기화
  let n = k; // 집합의 개수를 저장할 변수, 처음에는 모든 노드가 서로 다른 집합에 있으므로 k

  for (const op of operations) { // operations 리스트에 있는 연산들을 하나씩 처리
    if (op[0] === 'u') { // 'u' 연산이면
      union(parents, op[1], op[2]); // op[1]과 op[2]가 속한 집합을 합친다.
    } else if (op[0] === 'f') { // 'f' 연산이면
      find(parents, op[1]); // op[1]이 속한 집합의 루트 노드를 찾는다.
    }

    // 모든 노드의 루트 노드를 찾아서 집합의 개수를 계산
    n = new Set(Array.from({ length: k }, (_, i) => find(parents, i))).size;
  }

  return n; // 집합의 개수를 반환
}

console.log(solution(3,[['u', 0, 1], ['u', 1, 2], ['f', 2]])) // 반환값 : 1
console.log(solution(4,[['u', 0, 1], ['u', 2, 3], ['f', 0]])) // 반환값 : 2
```