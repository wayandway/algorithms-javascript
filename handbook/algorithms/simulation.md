## 시뮬레이션

### 시뮬레이션의 개념
- **시뮬레이션:** 주어진 문제 상황을 이해하고 이를 코드로 구현하여 문제의 요구를 충족시키는 과정
  - 다른 알고리즘과 달리 성능 최적화보다 구현 자체에 초점
  - 다양한 조건을 코드로 변환하는 능력이 중요

---

### 시뮬레이션 문제 풀이 팁
1. **문제를 세분화하기**  
   - 문제를 작은 단위로 분리하여 각각 독립적으로 구현
   - 이를 통해 코드 복잡도를 줄이고 디버깅을 용이하게 함
   - 예: 게임에서 캐릭터의 움직임, 공격, 점수 계산 등을 각각의 모듈로 구현

2. **예외 처리를 독립 함수로 구현하기**  
   - 기본 동작과 예외 처리가 섞이면 코드 가독성이 떨어지고, 유지보수가 어려워짐  
   - 예외 처리만을 담당하는 함수를 작성하여 구조화된 코드를 유지

---

### 행렬 연산
1. **행렬 덧셈과 뺄셈**  
   - 두 행렬의 크기가 같아야 연산 가능  
   - 예:  C[i][j] = A[i][j] + B[i][j] 

2. **행렬 곱셈**  
   -  A times B 에서  A의 열 크기와  B의 행 크기가 같아야 함
   - 결과 행렬  C의 크기는  A의 행 크기 X B의 열 크기


3. **전치 행렬**  
   - 행과 열을 바꾸는 연산
   -  A[i][j] <-> A[j][i] 

---

### 좌표 연산
1. **좌표 배열 표현**  
   - 2차원 좌표를 배열로 표현하여 연산 편의성을 높임
   - 예: (x, y) 좌표를 배열 arr[x][y]로 매핑

2. **좌표 이동 오프셋 활용**  
   - 여러 방향 이동을 하나의 배열로 표현하여 코드 간소화 가능 
   - 예: 네 방향 이동(상, 하, 좌, 우)을 다음과 같이 정의 
     ```javascript
     const dx = [-1, 1, 0, 0];
     const dy = [0, 0, -1, 1];
     for (let k = 0; k < 4; k++) {
         const nx = x + dx[k];
         const ny = y + dy[k];
         // 이동 조건 처리
     }
     ```

---

### 대칭 및 회전 연산
1. **대칭 연산**  
   - 정사각형 배열에서 좌우 대칭  
     `A[i][j] = A[i][N-1-j]`

2. **회전 연산**  
   - 90도 반시계 방향 회전
     `A[i][j] = A[N-1-j][i]`
   - 90도 시계 방향 회전
     `A[i][j] = A[j][N-1-i]`
   - 180도 회전: 90도 회전 연산을 두 번 수행


---

### 시뮬레이션 문제 예제
1. **게임 구현 문제**  
   - 캐릭터 이동, 공격, 점수 계산, 상태 관리 등을 세분화하여 구현

2. **퍼즐 문제**  
   - 행렬 회전, 대칭 등의 연산을 활용해 규칙 구현

3. **경로 탐색**  
   - 좌표 이동과 조건 검사를 통해 경로를 탐색

4. **행렬 조작**  
   - 데이터의 전치, 회전, 대칭을 요구하는 문제 해결

---

### 정리
- **시뮬레이션 문제의 핵심**  
  - 문제를 작은 단위로 나누어 독립적으로 구현  
  - 조건에 따른 예외 처리를 구조적으로 관리  
  - 다양한 연산(행렬, 좌표, 대칭, 회전)을 활용하여 문제를 해결