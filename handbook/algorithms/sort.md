## 정렬

### 정렬이 필요한 이유
- 데이터를 정렬하면 값을 보거나 비교할 필요 없이 데이터 전체에서 한 번에 원하는 값을 쉽게 찾을 수 있다.
---
### 1. 삽입 정렬
- 데이터의 전체 영역에서 정렬된 영역과 정렬되지 않은 영역을 나누고, 정렬되지 않은 영역의 값을 정렬된 영역의 적절한 위치로 놓으며 정렬하는 방식
- **키(Key)** : 정렬되지 않은 영역의 맨 앞에 있는 값
- **시간 복잡도** 
  - 최악의 경우: O(n^2)
  - 최선의 경우: O(n) (이미 정렬되어 있을 때)
---
### 2. 병합 정렬
- 정렬되지 않은 영역을 쪼개서 각각의 영역을 정렬하고 이를 합치며 정렬하는 방식 (분할 정복 방식)
- **병합 정렬의 과정**
  1. 데이터를 반으로 나눔
  2. 각 영역을 재귀적으로 정렬
  3. 정렬된 영역을 병합
- **시간 복잡도**
  - O(NlogN) -> 분할(logN) * 병합(N)
  - N개의 데이터를 1/2로 몇 번 나눠야 가장 작은 1칸이 될지 계산하는 식: logN (예: N이 8이면 log8=3, 즉 3번 나누고 이후 3번 정렬하며 합침)
---
### 3. 힙 정렬
#### 힙 자료구조
- **힙이란?** : 특정 규칙이 있는 이진 트리로, 규칙에 따라 최대힙/최소힙으로 나뉨
  - **최대힙** : 부모 노드가 자식 노드보다 큰 것
  - **최소힙** : 부모 노드가 자식 노드보다 작은 것
- **힙 구축 과정** (최대힙의 경우)
  - 인덱스 N/2부터 시작하여 힙을 구성함. 자식 노드가 없는 경우 아무런 동작도 하지 않으므로 효율적

#### 힙 정렬 과정 (최대힙의 경우)
1. 데이터를 힙 구조로 변환
2. 루트 노드를 삭제하고, 마지막 노드를 루트로 옮김
3. 힙의 규칙을 유지하도록 재정렬 (Heapify)
4. 위 과정을 반복하여 정렬 완료
- **시간 복잡도**
  - 힙 구성: O(N)
  - 정렬: O(NlogN) (각 데이터에 대해 logN 작업)

### 추가) 우선순위 큐 with 힙
- **우선순위 큐**: 우선순위에 따라 푸쉬/팝을 수행하는 큐
- **우선순위 큐의 동작 방식**
  - 최소힙/최대힙을 활용하여, 우선순위가 높은 데이터를 루트로 유지함
- **활용 분야**:
  - 작업 스케줄링, 응급실 대기열, 네트워크 트래픽 제어
  - 교통 네트워크 최적화: 최단 경로 알고리즘 구현
- **우선순위 큐 구현에 힙을 사용하는 이유**
  - 최소힙/최대힙의 루트 노드 특성(특정 값을 루트 노드에 유지)이 우선순위 큐의 핵심 동작(우선순위가 높은 데이터를 먼저 팝)과 일치
---
### 4. 위상 정렬
- 일의 순서가 있는 작업을 순서에 맞춰 정렬하는 알고리즘
- **특징**
  - 방향 비순환 그래프(DAG)에서만 사용 가능
  - 순환이 있거나 간선의 방향이 없으면 순서를 정의할 수 없음

#### 위상 정렬과 진입차수
- **진입차수**: 자신을 향한 화살표의 개수
  - 진입차수가 0이면 선행 작업이 없는 상태

#### 위상 정렬 과정
1. 진입차수가 0인 노드를 큐에 추가
2. 큐에서 노드를 제거하고 관련된 간선을 삭제
3. 간선 삭제로 인해 새로운 진입차수가 0이 된 노드를 큐에 추가
4. 위 과정을 반복하여 모든 노드를 정렬
- **시간 복잡도**: O(|V|+|E|) (정점과 간선의 개수)
---
### 5. 계수 정렬
- 데이터의 빈도수를 기반으로 정렬하는 방식
- **과정**
  1. 데이터의 범위 크기만큼의 배열을 생성
  2. 각 데이터의 빈도수를 배열에 기록
  3. 빈도수를 기반으로 데이터를 출력
- **시간 복잡도**: O(N+K) (N: 데이터 수, K: 범위 크기)

#### 계수 정렬의 한계
- 데이터의 값이 음수일 경우 추가적인 처리 필요
- 데이터의 범위가 너무 클 경우 비효율적
- 값이 듬성듬성 있을 경우 메모리 낭비 발생
---
### 정리


| 알고리즘      | 시간 복잡도 (최선) | 시간 복잡도 (최악) | 공간 복잡도 | 특이점                                                                                  |
|---------------|--------------------|--------------------|--------------|------------------------------------------------------------------------------------------|
| 삽입 정렬     | O(n)              | O(n²)             | O(1)         | 이미 정렬된 데이터에 대해 효율적이며, 적은 데이터에 적합                               |
| 병합 정렬     | O(NlogN)        | O(NlogN)        | O(n)         | 안정적인 정렬. 대규모 데이터에 적합하지만 병합 과정에서 추가 메모리 필요                              |
| 힙 정렬       | O(NlogN)        | O(NlogN)        | O(1)         | 데이터를 삽입과 동시에 빠르게 정렬 가능. 메모리 사용이 적어 제한된 환경에서 유리                                |
| 위상 정렬     | O(IVI+IEI)      | O(IVI+IEI)      | O(IVI)       | 방향 비순환 그래프에서만 사용 가능. 작업 스케줄링, 순서가 있는 작업에 유용             |
| 계수 정렬     | O(n + k)          | O(n + k)          | O(k)         | 데이터의 범위가 좁을 때 효율적. 음수 데이터나 범위가 클 경우 비효율적                  |


