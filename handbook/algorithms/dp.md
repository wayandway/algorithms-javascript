## 동적 계획법 (Dynamic Programming)

### 동적 계획법의 개념
- **작은 문제들을 해결하여 전체 문제를 해결**하는 방법
- 효율적인 사용 조건
  1. **중복 부분 문제**: 작은 문제가 반복적으로 등장해야 함
  2. **최적 부분 구조**: 큰 문제의 해결책이 작은 문제의 해결책의 합으로 구성될 수 있어야 함

---

### 점화식 세우기와 동적 계획법
1. 문제의 해가 이미 존재한다고 가정
2. 종료 조건 설정
3. 위 두 단계를 기반으로 **점화식**을 세움

---

### 예제 1: 팩토리얼 (재귀)
- 점화식
  - Fact(N) = Fact(N-1) * N  ( N > 1 )
  - Fact(1) = 1  ( N = 1 )
- 코드 (재귀)
  ```javascript
  function Fact(N) {
      if (N === 1) return 1; // 종료 조건
      return Fact(N - 1) * N; // 일반항
  }
  ```
- **단점**: 재귀 호출이 깊어질수록 메모리 부족 및 런타임 오류 발생 가능

---

### 재귀 호출을 최적화하는 메모이제이션
- **메모이제이션**: 이미 계산한 값을 저장하고 재사용하여 중복 연산 방지
- 팩토리얼 계산 시, 중간값 Fact(4), Fact(3)... 을 저장하면 성능이 개선됨

---

### 예제 2: 피보나치 수 (재귀 + 메모이제이션)
- **피보나치 수열**:  F(n) = F(n-1) + F(n-2) ,  F(1) = 1 ,  F(2) = 1 
- 코드 (의사코드)
  ```javascript
  let fibodata = Array(N + 1).fill(0); // 메모이제이션 배열

  function fibo(N) {
      if (fibodata[N] !== 0) return fibodata[N]; // 메모이제이션
      if (N <= 2) fibodata[N] = 1; // 종료 조건
      else fibodata[N] = fibo(N - 1) + fibo(N - 2); // 일반항
      return fibodata[N];
  }
  ```
- **효율**: 중복 계산 제거로 성능 향상

---

### 예제 3: 최장 증가 부분 수열 (Longest Increasing Subsequence, LIS)
- **부분 수열**: 수열의 일부 원소를 뽑아 만든 수열. 원소 간의 순서는 유지
- **최장 증가 부분 수열**: 원소가 **오름차순**을 유지하며 가장 긴 길이의 부분 수열

---

### 예제 4: 최장 공통 부분 수열 (Longest Common Subsequence, LCS)
- 두 수열의 공통된 부분 수열 중에서 가장 긴 수열을 찾는 문제
- 동적 계획법으로 효율적으로 해결 가능