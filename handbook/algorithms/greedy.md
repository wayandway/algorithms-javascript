## 그리디 알고리즘 (Greedy Algorithm)

### 개념
- **결정 순간마다 가장 최선의 선택**을 하며, 선택을 번복하지 않는 알고리즘
- 부분적으로 최적의 해를 구할 수 있지만, **전체 최적해를 항상 보장하지는 않음**

---

### 그리디 알고리즘의 적용 조건
1. **최적 부분 구조**: 부분 문제의 최적해가 전체 문제의 최적해를 구성해야 함
2. **그리디 선택 속성**: 현재 선택이 이후 선택에 영향을 주지 않아야 함

---

### 특징
- 항상 최적해를 보장하지는 않음
- 하지만 빠른 시간 내에 **근사해**를 제공하므로, 문제 특성에 따라 유용하게 사용 가능

---

### 예시: 거스름돈 문제
- 동전 종류가 \(5, 4, 1\)원이고, 동전 개수를 최소화하려면
  1. 가장 큰 단위 동전부터 선택
  2. 남은 금액에 대해 반복

---

### 최소 신장 트리 (MST)
- **신장 트리**: 모든 정점이 간선으로 연결된 트리로,`간선의 개수 = 정점의 개수 - 1`
- **최소 신장 트리 (MST)**: 간선의 가중치 합이 최소인 신장 트리

#### MST를 구하는 그리디 알고리즘
1. **프림 알고리즘**
   - 과정
     1. 임의의 정점을 선택하여 MST에 추가
     2. MST와 연결된 정점 중 가중치가 가장 적은 정점을 추가
     3. 사이클을 형성하지 않는 범위 내에서 반복
   - 특징: 임의 정점에서 최소 인접 가중치를 가지는 정점을 찾아 확장하는 방식

2. **크루스칼 알고리즘**
   - 과정
     1. 모든 간선을 가중치 기준으로 오름차순 정렬
     2. 가중치가 낮은 간선부터 하나씩 추가
     3. 사이클을 형성하지 않는 범위 내에서 반복
   - 특징: 최소 가중치를 가지는 간선부터 하나씩 추가하는 방식

---

### 배낭 문제 (Knapsack Problem)
- **문제**: 배낭의 최대 용량을 초과하지 않으면서 담은 물건의 가치를 최대로 만드는 문제

#### 1. 부분 배낭 문제 (Fractional Knapsack)
- 물건을 **쪼개서** 배낭에 담을 수 있음
- **그리디 알고리즘 적용 가능**
  1. 각 물건의 **무게당 가치**를 계산
  2. 무게당 가치가 높은 물건부터 배낭에 담음
  3. 배낭 용량이 부족하면 물건을 쪼개서 담음
- **최적해를 보장**
  - 최적 부분 구조와 그리디 선택 속성을 모두 만족

#### 2. 0/1 배낭 문제 (0/1 Knapsack)
- 물건을 **쪼갤 수 없음**
- **그리디 알고리즘 적용 불가**
  - 선택한 물건이 이후 선택에 영향을 줌
- **최적해를 구하려면 동적 계획법** 사용 필요

--- 

### 요약
- **그리디 알고리즘**은 문제의 특성에 따라 빠르고 간단하게 근사해를 제공
- 그러나, 최적해를 보장하려면 **최적 부분 구조**와 **그리디 선택 속성**을 만족해야 함
- 대표적인 활용 예시
  - 최소 신장 트리: 프림, 크루스칼 알고리즘
  - 부분 배낭 문제